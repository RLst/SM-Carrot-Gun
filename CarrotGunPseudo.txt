// Game Flow and Mechanics
// =========================

√ - The users face shall appear behind in the back

√ - A cannon object will be oscillating back and forth, aiming towards some target objects on the right side of the screen

3h - The targets are placed randomly and their swimming circle is calculated...
  - At least a certain minimum distance from each other
  - A minimum distance from the edge of the screen
  - At least a minimum distance from the player
  - Their swimming circle radius will be set randomly within a range but not greater than the distance to the edge of the screen

√ - The user fires the gun by opening their mouth
  √ - Only one projectile at a time
  √ - During a shot the gun must stop oscillating
  √ - If the projectile doesn't hit anything it just keeps going until it goes out of the screen
  √ - Once the projectile is offscreen the gun is able to move and fire again

2h - Once a target is hit:
  - Game will momentarily pause
  - Animate: Shake, glow, shine, explode, disappear, etc
  - Topic text of the fish will appear where the fish is
  - Topic text and random message will appear on the user's head, 3 seconds so they can read it
  - Once the text disappears the game will resume
  - Game will continue until all targets are hit

Game ending
  - Once all targets are hit, a results plaque will be displayed


Oscillating cannon
==================
• Linear
  Rotate Z
• Sinoidal
  Rotate using sin
• Tweening
  Use "Transit in Time" nodes

Functionality required
==================
Shoot
1. Position and rotate object at desired muzzle point
2. For every frame move forward by a specified amount in the facing direction
  Velocity
  bullet.pos.x = bullet.pos.x + cos(bullet.rotation) * speed * Time.deltaTime;
  bullet.pos.y = bullet.pos.y + sin(bullet.rotation) * speed * Time.deltaTime;

  bullet.movement = cos/sin(bullet.rotation) * speed * Time.deltaTime;


  position = curPosition;
  velocity = newVelocity;

  newVelocity = velocity + gravity * Time.deltaTime;
  newPosition = position + velocity * Time.deltaTime;

Find the nearest distance from the object to a screen's edge
==================
Vec2 target = new Vec2(100, -540);

int closest = int.INFINITY;

if (screen.x - abs(target.x) < closest)
  closest = screen.x - abs(target.x);
if (screen.y - abs(target.y) < closest)
  closest = screen.y - abs(target.y);

360 - abs(100) = 260
closest = 260
720 - abs(620) = 100
closest = 100

Target hit sequence
===================
1. Game has started
2. Bullet has been fired
3. Bullet hits target
4. Target starts death animation
5. Corresponding topic is displayed at the hit target
6. Game pauses until text has finished displaying
  - isPaused = true
  - isFiring = true
7. Resume turret, reset bullet


Countdown timer
==========
- Easy
-

Time limit
==========
Requirements
- Timer inits at 45s
- Timer starts countdown on first shot fired
- On

//States
bool isFiring;
bool isPlaying;
float timeLeft;
float time;
float deltaTime;
Texture Message0;
Texture Message1;
Texture Message2;
Texture Message3;
Texture Message4;


void Update()
{
  if (!isPlaying)
  {
    return;
  }

  UpdateBullet();
  UpdateCountdownTimer();
  UpdateGameTimers();
}

void OnUserInput()
{
  if (isPlaying == false && isGameStarted == false)
  {
    isGameStarted = true;
    isPlaying = true;
  }

  FireBullet();
}

void FireBullet()
{
  if (!isFiring)
  {
    isFiring = true;

    Activate bullet
    Init bullet position
    Animate bullet once
  }

  AnimateMuzzleFlash();..
}

void UpdateBullet()
{
  if (isFiring && bullet.active)
  {
    Move bullet according to speed and orientation
  }
}

void UpdateCountdownTimer()
{

}

void UpdateGameTimers()
{
  deltaTime = Time.deltaTime;
  time += deltaTime;
}

==========
Algorithm

• Preset all topic indices first ie. suc khoe, ban be, tinh duyen
• Preset all topic messages ie.
  topic 0: suk khoe -> message0: sk4
• Preset all message textures
  message0: sk4 tex
